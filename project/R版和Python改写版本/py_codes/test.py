#coding:utf-8
import numpy as np
l1 = [11386.200,10712.600,10851.000,9309.000,9150.000,15237.000,12125.250,
        16305.667,9301.000,17853.200,13098.000,10149.167,8920.250,15157.000,
        6529.000,12557.000,12988.000,7776.333,10640.000,8983.500,5523.000,]

l2 = [13098.000,10149.167,8920.250,15157.000,6529.000,12557.000,12988.000,
        7776.333,10640.000,8983.500,5523.000,7388.000,10534.500,6788.333,
        15940.667,9974.250,9876.000,0.000,14095.250,13855.500,8413.500,]

l3 = [12557.000,12988.000,7776.333,10640.000,8983.500,5523.000,7388.000,
        10534.500,6788.333,15940.667,9974.250,9876.000,0.000,14095.250,
        13855.500,8413.500,17105.667,3558.000,29915.500,0.000,18243.667,]

l = l3

# Z-Score的绝对值大于3通常视为异常
# 通过Z-Score的绝对值最大 == outlier()筛选得到的
list_zscore = [abs((i-np.mean(l))/np.std(l)) for i in l]
d1 = zip(l, list_zscore)
d2 = sorted(d1, key = lambda item:item[1], reverse=True)
for info in d2:
    print info[1], info[0]
# 当l = l3时, Z-Score最高的不是为0的, 但为0的肯定是有问题的
# 就是因为会出现这种情况才循环多次吗? 循环固定次数可能会适得其反
# 在R中 outlier()每次返回Z-Score最大的那个, 但是最大的那个可能没有问题
# 如何界定异常值有点麻烦(但是显而易见的0必须率先修正)
# 2.97947735841 29915.5
# 1.65286124422 0.0
# 1.65286124422 0.0
# 1.17212389384 18243.667
# 1.10191405136 3558.0


#d1 = dict(zip(l, list_zscore))
#d2 = sorted(d1.items(), key = lambda item:item[1], reverse=True)
#print d2[0][0]




